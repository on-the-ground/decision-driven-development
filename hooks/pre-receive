#!/bin/bash
# ============================================================================
# Pre-receive hook for Decision-Driven Development Policy (Server-side)
# ============================================================================

set -euo pipefail

# Find and source DDD root detection library
# When installed as git hook, we need to find the actual DDD system location
if [[ -f "${HOME}/.local/share/ddd-system/lib/ddd_root.sh" ]]; then
    source "${HOME}/.local/share/ddd-system/lib/ddd_root.sh"
elif [[ -f "$(dirname "${BASH_SOURCE[0]}")/../lib/ddd_root.sh" ]]; then
    # Fallback for development environment
    source "$(dirname "${BASH_SOURCE[0]}")/../lib/ddd_root.sh"
else
    echo "‚ùå ERROR: Cannot find ddd_root.sh" >&2
    echo "Expected at: ${HOME}/.local/share/ddd-system/lib/ddd_root.sh" >&2
    exit 1
fi

# Find the DDD system root
DDD_ROOT=$(find_ddd_root) || exit 1

# Source validation library
source "$DDD_ROOT/lib/validation.sh"

echo "üõ°Ô∏è  Server-side decision policy enforcement..."

violation=false
while read -r oldrev newrev refname; do
    # Skip branch deletions
    [[ "$newrev" == "0000000000000000000000000000000000000000" ]] && continue
    
    log_debug "Validating receive for $refname ($oldrev..$newrev)"
    
    # Get changed files (using new path for renames)
    changed_files=()
    mapfile -t changed_files < <(get_changed_files_in_range "$oldrev" "$newrev")
    
    if [[ ${#changed_files[@]} -eq 0 ]]; then
        log_debug "No files changed in $refname"
        continue
    fi
    
    # Get added decision directories
    declare -A added_decision_dirs=()
    while IFS=$'\t' read -r status p1 p2; do
        case "$status" in
            A*|C*|R*)
                path="${p2:-$p1}"
                if is_decision_file "$path"; then
                    added_decision_dirs["$(dirname "$path")"]=1
                fi
                ;;
        esac
    done < <(git diff --name-status "$oldrev..$newrev" 2>/dev/null || true)
    
    # Get directories that have .decision subdirectories in this commit
    declare -A decision_exempted_dirs=()
    while IFS=$'\t' read -r status p1 p2; do
        case "$status" in
            A*|C*|R*)
                path="${p2:-$p1}"
                if [[ "$path" == *"/.decision/"* ]]; then
                    # Extract the parent directory that contains .decision
                    parent_dir="${path%%/.decision/*}"
                    decision_exempted_dirs["$parent_dir"]=1
                fi
                ;;
        esac
    done < <(git diff --name-status "$oldrev..$newrev" 2>/dev/null || true)
    
    # Validate each file
    errors=()
    for file in "${changed_files[@]}"; do
        should_validate_file "$file" || continue
        
        # Check if this file is under a directory that has .decision changes
        file_exempted=false
        for exempt_dir in "${!decision_exempted_dirs[@]}"; do
            if [[ "$file" == "$exempt_dir"/* ]]; then
                file_exempted=true
                break
            fi
        done
        
        # If file is exempted, skip validation
        if [[ "$file_exempted" == true ]]; then
            continue
        fi
        
        decision_dir=""
        decision_dir=$(find_nearest_decision_dir "$file")
        
        # Check if decision directory exists in new tree
        if ! git ls-tree -d --name-only "$newrev" -- "$decision_dir" >/dev/null 2>&1; then
            errors+=(" - $file ‚ûú missing nearest decision dir in received tree: $decision_dir")
            continue
        fi
        
        # Check if new decision was added to this directory
        if [[ -z "${added_decision_dirs["$decision_dir"]+x}" ]]; then
            errors+=(" - $file ‚ûú no new decision added under $decision_dir in this receive")
        fi
    done
    
    if [[ ${#errors[@]} -gt 0 ]]; then
        violation=true
        log_error "SERVER REJECTED: Decision policy violations detected on $refname"
        printf '%s\n' "${errors[@]}" >&2
    fi
done

if [[ "$violation" == true ]]; then
    exit 1
fi

echo "‚úÖ Server-side validation passed"